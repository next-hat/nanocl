use nanocl_stubs::{vm_config, vm};

use crate::schema;

use super::namespace::NamespaceDbModel;

/// ## VmDbModel
///
/// This structure represent the vm in the database.
/// A vm is a virtual machine that is running on the server.
/// The vm is linked to a namespace.
/// We use the `config_key` to link to the vm config.
/// The `key` is used to identify the vm and is generated as follow: `namespace_name-vm_name`.
///
#[derive(Clone, Debug, Queryable, Identifiable, Insertable, Associations)]
#[diesel(primary_key(key))]
#[diesel(table_name = schema::vms)]
#[diesel(belongs_to(NamespaceDbModel, foreign_key = namespace_name))]
pub struct VmDbModel {
  /// The key of the vm
  pub(crate) key: String,
  /// The created at date
  pub(crate) created_at: chrono::NaiveDateTime,
  /// The name of the vm
  pub(crate) name: String,
  /// The config key reference
  pub(crate) config_key: uuid::Uuid,
  /// The namespace name reference
  pub(crate) namespace_name: String,
}

impl VmDbModel {
  pub fn into_vm(self, config: vm_config::VmConfig) -> vm::Vm {
    vm::Vm {
      key: self.key,
      name: self.name,
      config_key: config.key,
      namespace_name: self.namespace_name,
      config,
    }
  }
}

/// ## VmUpdateDbModel
///
/// This structure is used to update a vm in the database.
///
#[derive(Debug, Default, AsChangeset)]
#[diesel(table_name = schema::vms)]
pub struct VmUpdateDbModel {
  /// The key of the vm
  pub(crate) key: Option<String>,
  /// The namespace name reference
  pub(crate) namespace_name: Option<String>,
  /// The name of the vm
  pub(crate) name: Option<String>,
  /// The config key reference
  pub(crate) config_key: Option<uuid::Uuid>,
}
